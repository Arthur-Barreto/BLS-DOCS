{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":"<p>This page provides an overview of my Summer Research Project at the University of Illinois at Urbana-Champaign, where I worked under the guidance of Professor Lawrence Rauchwerger. The project focuses on optimizing the Box Least Squares (BLS) algorithm for planetary transit detection. This two-month research effort marks the beginning of a longer-term project, and I'm excited to share our progress and results.</p> <p></p> <p>The primary goal of this work is to implement a parallel version of the BLS algorithm, which is essential for analyzing data from space missions like Kepler and K2. By leveraging parallel computing frameworks, including OpenMP, MPI, and GPU acceleration through PyTorch, we aim to improve the efficiency of the BLS algorithm. Additionally, the STAPL library, which abstracts the use of OpenMP and MPI, plays a crucial role in our approach.</p> <p>One of the suggested improvements for this project is optimizing the candidate generation process for the BLS algorithm. This involves ensuring that key parameters, such as the transit period, are accurately represented in a comprehensive set of candidates for testing.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>For more detailed information about the project, please refer to the following documentation:</p> <ul> <li>The BLS Algorithm</li> <li>Implementation in Different Technologies</li> </ul> <p>Each page offers a comprehensive explanation of the respective implementation, including detailed descriptions of key functions and algorithms.</p>"},{"location":"#how-to-contribute","title":"How to contribute","text":"<p>If you're interested in contributing to this project, please visit the contributing page for detailed information on how to get involved.</p>"},{"location":"#credits-and-attributions","title":"Credits and Attributions","text":"<p>This project makes use of the following open-source projects:</p> <ul> <li>lightkurve: A friendly package for Kepler &amp; TESS time series analysis in Python.</li> <li>License: MIT License</li> <li> <p>Source: GitHub Repository</p> </li> <li> <p>Astropy: A comprehensive library for astronomy-related computations and data manipulation, providing tools for working with astronomical data and performing complex calculations.</p> </li> <li>License: BSD-3-Clause License</li> <li>Source: GitHub Repository</li> </ul>"},{"location":"bls/","title":"The BLS Algorithm","text":"<p>Loren Ipsum</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"implementation/","title":"Implementation","text":"<p>This page provides a guide for each version of the BLS (Box Least Squares) algorithm, including implementations in sequential, OpenMP, MPI, STAPL, and PyTorch. Each section offers a detailed explanation of the respective implementation, including descriptions of functions and key components.</p>"},{"location":"implementation/#overview","title":"Overview","text":"<p>The following structs are used throughout the implementation, for defining functions types:</p> <pre><code>struct PERIODParameters {\n  double minimum_period;\n  double maximum_period;\n  double total_duration;\n};\n</code></pre> <ul> <li><code>PERIODParameters</code> holds the range of periods and the total time duration for the analysis.</li> </ul> <pre><code>struct BLSResult {\n  double best_period;\n  double best_duration;\n  double best_phase;\n  double best_d_value;\n};\n</code></pre> <ul> <li><code>BLSResult</code> stores the results of the BLS algorithm, including the best period, best duration, best phase, and the lowest d-value (the metrics used to evaluate the best fit).</li> </ul> <p>Additionally, the following typedef is used in the implementation:</p> <pre><code>typedef std::tuple&lt;double, double, double&gt; SPECParameters;\n</code></pre>"},{"location":"implementation/#core-functions","title":"Core Functions","text":"Function name Description <code>min_value</code> Returns the minimum value in a vector. <code>max_value</code> Returns the maximum value in a vector. <code>ptp</code> Returns the peak-to-peak value in a vector. <code>arange</code> Generates a range of values. <code>linspace</code> Generates a linearly spaced range of values. <code>auto_phase</code> Generates a phase vector. <code>auto_max_min_period</code> Generates the maximum and minimum period. <code>auto_period</code> Generates a period vector. <code>spec_generator</code> Generates a vector of SPEC parameters. <code>spec_generator_gambiarra</code> Generates a vector of SPEC parameters. <code>compute_trel</code> Computes the relative time vector. <code>normalize</code> Normalizes a vector. <code>compute_weights</code> Computes the weights vector. <code>model</code> Computes the model for the BLS algorithm. <code>bls</code> Computes the BLS algorithm. <code>readCSV</code> Reads a CSV file."},{"location":"implementation/#detailed-function-descriptions","title":"Detailed Function Descriptions","text":"<p>"},{"location":"implementation/#min_value","title":"<code>min_value</code>","text":"<pre><code>template &lt;typename T&gt; T min_value(const std::vector&lt;T&gt; &amp;v);\n</code></pre> <p>Description Get the minimum element in a vector.</p> <p>Parameters: </p> <ul> <li><code>T</code> Type of the elements in the vector.</li> <li><code>v</code> The vector from which to get the minimum value</li> </ul> <p>Returns:   The minimum element in the vector.</p> <p>"},{"location":"implementation/#max_value","title":"<code>max_value</code>","text":"<pre><code>template &lt;typename T&gt; T max_value(const std::vector&lt;T&gt; &amp;v);\n</code></pre> <p>Description Get the maximum element in a vector.</p> <p>Parameters: </p> <ul> <li><code>T</code> Type of the elements in the vector.</li> <li><code>v</code> The vector from which to get the maximum value</li> </ul> <p>Returns:   The maximum element in the vector.</p> <p>"},{"location":"implementation/#ptp","title":"<code>ptp</code>","text":"<pre><code>template &lt;typename T&gt; T ptp(const std::vector&lt;T&gt; &amp;v);\n</code></pre> <p>Description Get the peak-to-peak value in a vector, which is the difference between the maximum and minimum values.</p> <p>Parameters: </p> <ul> <li><code>T</code> Type of the elements in the vector.</li> <li><code>v</code> The vector from which to get the peak-to-peak value</li> </ul> <p>Returns:   The peak-to-peak value in the vector.</p> <p>"},{"location":"implementation/#arange","title":"arange","text":"<pre><code>std::vector&lt;double&gt; arange(double start, double end, double step);\n</code></pre> <p>Description Generates a range of values from <code>start</code> to <code>end</code> with a given step size. It's similar to the <code>numpy.arange</code> function in Python.</p> <p>Parameters: </p> <ul> <li><code>start</code> The starting value of the range.</li> <li><code>end</code> The ending value of the range, not inclusive.</li> <li><code>step</code> The step size between values.</li> </ul> <p>Returns:   A vector of values from <code>start</code> to <code>end</code> with a step size of <code>step</code>.</p> <p>"},{"location":"implementation/#linspace","title":"linspace","text":"<pre><code>std::vector&lt;double&gt; linspace(double start, double end, size_t num);\n</code></pre> <p>Description Generates a linearly spaced range of values from <code>start</code> to <code>end</code> with a given number of elements. It's similar to the <code>numpy.linspace</code> function in Python.</p> <p>Parameters:</p> <ul> <li><code>start</code> The starting value of the range.</li> <li><code>end</code> The ending value of the range.</li> <li><code>num</code> The number of elements in the range.</li> </ul> <p>Returns:   A vector of <code>num</code> values from <code>start</code> to <code>end</code>.</p> <p>"},{"location":"implementation/#auto_phase","title":"auto_phase","text":"<pre><code>std::vector&lt;double&gt; auto_phase(double period, double duration);\n</code></pre> <p>Description Generates a vector os phases for a given period and duration. It's the cpp version of the <code>auto_phase</code> function from <code>astropy</code>.</p> <p>Parameters:</p> <ul> <li><code>period</code> The period of the signal.</li> <li><code>duration</code> The duration of the signal.</li> </ul> <p>Returns:   A vector of phases.</p> <p>"},{"location":"implementation/#auto_max_min_period","title":"auto_max_min_period","text":"<pre><code>PERIODParameters auto_max_min_period(std::vector&lt;double&gt; &amp;time);\n</code></pre> <p>Description Generates the maximum and minimum period for a given time vector. It's the cpp version of the <code>auto_max_min_period</code> function from <code>astropy</code>.</p> <p>Parameters:</p> <ul> <li><code>time</code> The time vector.</li> </ul> <p>Returns:   A <code>PERIODParameters</code> struct with the minimum period, maximum period, and total duration of the time vector (it's the <code>ptp</code> of the time vector).</p> <p>"},{"location":"implementation/#auto_period","title":"auto_period","text":"<pre><code>std::vector&lt;double&gt; auto_period(double minimum_period = -1,\n                                double maximum_period = -1,\n                                double total_duration = -1);\n</code></pre> <p>Description Generates a vector of periods, given the minimum period, maximum period, and total duration. It's the cpp version of the <code>auto_period</code> function from <code>astropy</code>.</p> <p>Parameters:</p> <ul> <li><code>minimum_period</code> The minimum period.</li> <li><code>maximum_period</code> The maximum period.</li> <li><code>total_duration</code> The total duration.</li> </ul> <p>Returns:   A vector of periods.</p> <p>"},{"location":"implementation/#spec_generator","title":"spec_generator","text":"<pre><code>std::vector&lt;SPECParameters&gt; spec_generator(std::vector&lt;double&gt; &amp;time);\n</code></pre> <p>Description Generates a vector of <code>SPECParameters</code> for a given time vector. This function is used to generate the candidates for running the BLS algorithm. However, it currently needs improvements as it generates a large number of candidates.</p> <p>Parameters:</p> <ul> <li><code>time</code> The time vector.</li> </ul> <p>Returns:   A vector of <code>SPECParameters</code>, which are tuples of <code>(period, duration, phase)</code>, the candidates for the BLS algorithm.</p> <p>"},{"location":"implementation/#spec_generator_gambiarra","title":"spec_generator_gambiarra","text":"<pre><code>std::vector&lt;SPECParameters&gt; spec_generator_gambiarra(std::vector&lt;double&gt; &amp;time);\n</code></pre> <p>Description It's the simple version of the <code>spec_generator</code> function. It generates a vector of <code>SPECParameters</code> for a given time vector. This function is used to generate the candidates for running the BLS algorithm.</p> <p>Parameters:</p> <ul> <li><code>time</code> The time vector.</li> </ul> <p>Returns:   A vector of <code>SPECParameters</code>, which are tuples of <code>(period, duration, phase)</code>, the candidates for the BLS algorithm.</p> <p>"},{"location":"implementation/#compute_trel","title":"compute_trel","text":"<pre><code>std::vector&lt;double&gt; compute_trel(std::vector&lt;double&gt; &amp;time);\n</code></pre> <p>Description The <code>compute_trel</code> function calculates the relative time vector. It subtracts the minimum value of the time vector (<code>t0</code>) from each element, returning a vector of relative times. This is useful for normalizing the time data for further processing.</p> <p>Parameters:</p> <ul> <li><code>time</code>   A vector of time values (<code>std::vector&lt;double&gt;</code>), typically representing the time data.</li> </ul> <p>Returns:   A vector of relative time values (<code>std::vector&lt;double&gt;</code>), where each value is the difference between the corresponding time and the minimum value in the input time vector.</p> <p>"},{"location":"implementation/#normalize","title":"normalize","text":"<pre><code>std::vector&lt;double&gt; normalize(std::vector&lt;double&gt; &amp;flux);\n</code></pre> <p>Description The <code>normalize</code> function takes a vector of flux values and normalizes them by subtracting the mean and dividing by the standard deviation. This is useful for transforming the flux data to have a mean of 0 and standard deviation of 1, which is common in many data analysis techniques.</p> <p>Parameters:</p> <ul> <li><code>flux</code>   A vector of flux values (<code>std::vector&lt;double&gt;</code>), representing the signal data.</li> </ul> <p>Returns:   A normalized vector of flux values (<code>std::vector&lt;double&gt;</code>), where each value is the original flux value minus the mean, divided by the standard deviation.</p> <p>"},{"location":"implementation/#compute_weights","title":"compute_weights","text":"<pre><code>std::vector&lt;double&gt; compute_weights(std::vector&lt;double&gt; &amp;flux_err);\n</code></pre> <p>Description The <code>compute_weights</code> function calculates the weights based on the provided flux errors. The weights are computed as the inverse square of the flux errors and are normalized so that their sum is 1. This is commonly used in weighted averaging or fitting algorithms where data points have different uncertainties.</p> <p>Parameters:</p> <ul> <li><code>flux_err</code>   A vector of flux error values (<code>std::vector&lt;double&gt;</code>), representing the uncertainty in the flux measurements.</li> </ul> <p>Returns:   A vector of normalized weights (<code>std::vector&lt;double&gt;</code>), where each weight is inversely proportional to the square of the corresponding flux error and normalized so that the sum of the weights is 1.</p> <p>"},{"location":"implementation/#model","title":"model","text":"<pre><code>double model(std::vector&lt;double&gt; &amp;t_rel, std::vector&lt;double&gt; &amp;flux,\n             std::vector&lt;double&gt; &amp;weights, double period, double duration,\n             double phase);\n</code></pre> <p>Description The <code>model</code> function is crucial as it evaluates the metrics to determine the presence of a transit. It assesses a transit model using the provided time, flux, weights, period, duration, and phase. By calculating the occurrence of a transit at each point in the time vector and applying weighted averages, it computes a goodness-of-fit metric (<code>d_value</code>). This metric is essential for identifying the best-fitting transit model.</p> <p>Parameters:</p> <ul> <li> <p><code>t_rel</code>   A vector of relative time values (<code>std::vector&lt;double&gt;</code>), which represents the time data normalized by subtracting the minimum value.</p> </li> <li> <p><code>flux</code>   A vector of flux values (<code>std::vector&lt;double&gt;</code>), representing the observed light curve data.</p> </li> <li> <p><code>weights</code>   A vector of weights (<code>std::vector&lt;double&gt;</code>), computed from the flux errors.</p> </li> <li> <p><code>period</code>   The period of the transit event (in the same units as the time vector).</p> </li> <li> <p><code>duration</code>   The duration of the transit event.</p> </li> <li> <p><code>phase</code>   The phase of the transit event, specifying where in the period the transit occurs.</p> </li> </ul> <p>Returns:   A <code>double</code> representing the calculated goodness-of-fit metric (<code>d_value</code>) for the given transit model. This value is useful for determining how well a transit model fits the data.</p> <p>"},{"location":"implementation/#bls","title":"bls","text":"<pre><code>BLSResult bls(std::vector&lt;double&gt; &amp;time, std::vector&lt;double&gt; &amp;flux,\n              std::vector&lt;double&gt; &amp;flux_err,\n              std::vector&lt;SPECParameters&gt; &amp;s_params);\n</code></pre> <p>Description The <code>bls</code> function implements the Box Least Squares (BLS) algorithm for detecting periodic transit-like events in a time series of flux measurements. It evaluates various candidate models based on the input parameters (period, duration, and phase) and returns the model that best fits the data, according to a goodness-of-fit metric (<code>d_value</code>).</p> <p>Parameters:</p> <ul> <li> <p><code>time</code>   A vector of time values (<code>std::vector&lt;double&gt;</code>), representing the time data for the light curve.</p> </li> <li> <p><code>flux</code>   A vector of flux values (<code>std::vector&lt;double&gt;</code>), representing the observed light curve data.</p> </li> <li> <p><code>flux_err</code>   A vector of flux error values (<code>std::vector&lt;double&gt;</code>), representing the uncertainty in the flux measurements.</p> </li> <li> <p><code>s_params</code>   A vector of <code>SPECParameters</code> (<code>std::vector&lt;SPECParameters&gt;</code>), which are tuples of <code>(period, duration, phase)</code> representing the candidate transit models to evaluate.</p> </li> </ul> <p>Returns:   A <code>BLSResult</code> structure, which contains the following:</p> <ul> <li> <p><code>best_d_value</code>   The best goodness-of-fit metric (<code>double</code>) found during the search.</p> </li> <li> <p><code>best_period</code>   The period (<code>double</code>) of the best-fitting transit model.</p> </li> <li> <p><code>best_duration</code>   The duration (<code>double</code>) of the best-fitting transit model.</p> </li> <li> <p><code>best_phase</code>   The phase (<code>double</code>) of the best-fitting transit model.</p> </li> </ul> <p>"},{"location":"implementation/#readcsv","title":"readCSV","text":"<pre><code>void readCSV(const std::string &amp;filename, std::vector&lt;double&gt; &amp;time,\n             std::vector&lt;double&gt; &amp;flux, std::vector&lt;double&gt; &amp;flux_err);\n</code></pre> <p>Description The <code>readCSV</code> function reads a CSV file and extracts the time, flux, and flux error values into the provided vectors. The function assumes that the CSV file contains at least three columns (time, flux, and flux error) and that the first line is a header.</p> <p>Parameters:</p> <ul> <li> <p><code>filename</code>   A <code>string</code> representing the path to the CSV file.</p> </li> <li> <p><code>time</code>   A vector of time values (<code>std::vector&lt;double&gt;</code>), which will be filled with the time data from the file.</p> </li> <li> <p><code>flux</code>   A vector of flux values (<code>std::vector&lt;double&gt;</code>), which will be filled with the flux data from the file.</p> </li> <li> <p><code>flux_err</code>   A vector of flux error values (<code>std::vector&lt;double&gt;</code>), which will be filled with the flux error data from the file.</p> </li> </ul> <p>Returns:   This function does not return a value, but it populates the provided <code>time</code>, <code>flux</code>, and <code>flux_err</code> vectors with data from the CSV file. If the file cannot be opened, an error message is printed to <code>stderr</code>.</p>"},{"location":"implementation/#sequential-implementation","title":"Sequential Implementation","text":""},{"location":"implementation/#openmp-implementation","title":"OpenMP Implementation","text":""},{"location":"implementation/#mpi-implementation","title":"MPI Implementation","text":""},{"location":"implementation/#stapl-implementation","title":"STAPL Implementation","text":""},{"location":"implementation/#pytorch-implementation","title":"PyTorch Implementation","text":""},{"location":"results/","title":"Results","text":""}]}